##自我保护的概念
先看一下eureka官方对这个概念的描述，在根据代码来看下。  
[官方定义地址](https://github.com/Netflix/eureka/wiki/Server-Self-Preservation-Mode)

> Eureka servers will enter self preservation mode if they detect that a larger than expected number of registered clients have terminated their connections in an ungraceful way, and are pending eviction at the same time. This is done to ensure catastrophic network events do not wipe out eureka registry data, and having this be propagated downstream to all clients.

如果Eureka服务器检测到超过预期数量的已注册客户端以不公平的方式终止了它们的连接，并且正在等待收回，那么它们将进入自我保护模式。这样做是为了确保灾难性的网络事件不会清除eureka注册表数据，并将其传播到下游的所有客户端

> To better understand self preservation, it help to first understand how does eureka clients 'end' their registration lifecycle. The eureka protocol requires clients to execute an explicit unregister action when they are permanently going away. For example, in the provided java client, this is done in the shutdown() method. any clients that fails 3 consecutive heartbeat renewals is considered to have an unclean termination, and will be evicted by the background eviction process. It is when > 15% of the current registry is in this later state, that self preservation will be enabled.

为了更好地理解自我保护，首先了解eureka客户机如何“结束”其注册生命周期很有帮助。eureka协议要求客户端在永久离开时执行显式的注销操作。例如，在提供的java客户机中，这是在shutdown（）方法中完成的。任何连续3次心跳更新失败的客户端都将被视为具有不干净的终止，并将被后台逐出进程逐出。当当前注册表的>15%处于稍后的状态时，将启用自我保护。

> When in self preservation mode, eureka servers will stop eviction of all instances until either:
  
  1. the number of heartbeat renewals it sees is back above the expected threshold, or
  2. self preservation is disabled (see below)
  
当处于自我保护模式时，eureka服务器将停止逐出所有实例，直到已下两种情况发生：
1. 心跳更新次数重新高于预期阈值
2. 自我保护被禁用

>  Self preservation is enabled by default, and the default threshold for enabling self preservation is > 15% of the current registry size.

默认情况下启用自我保护，并且启用自我保护的默认阈值大于当前注册表大小的15%。


##源码分析
源码只列一些相关的参数和代码如下所示：  
```java
public abstract class AbstractInstanceRegistry implements InstanceRegistry {
    //记录上一分钟续约请求的个数
    private final MeasuredRate renewsLastMin;
    //每分钟续约请求的最小阀值
    protected volatile int numberOfRenewsPerMinThreshold;
    //期待有多少个客户端来发送续约请求
    protected volatile int expectedNumberOfClientsSendingRenews;

    public void register(InstanceInfo registrant, int leaseDuration, boolean isReplication) {
        //省略部分代码。。。

        //新的实例来进行注册时，将expectedNumberOfClientsSendingRenews加1，默认值是1
        this.expectedNumberOfClientsSendingRenews = this.expectedNumberOfClientsSendingRenews + 1;
        //
        updateRenewsPerMinThreshold();

        //省略部分代码。。。
    }
    
    //更新每分钟续约请求的最小阀值
    protected void updateRenewsPerMinThreshold() {
        //serverConfig.getExpectedClientRenewalIntervalSeconds() 这个参数是客户端每隔几秒进行一次续约，默认是30s
        //serverConfig.getRenewalPercentThreshold() 这个参数是自我保护模式启动的阀值，默认是0.85
        //情况1： 刚启动一个eureka服务，并且没有注册任何实例进来（自己也不注册），
        //expectedNumberOfClientsSendingRenews是1，那么numberOfRenewsPerMinThreshold计算出来的结果就是1
        //但是因为没有注册任何实例，也就不会收到续约请求，过一段时间eureka管理页面上就可以看到进入了自我保护模式。
        //比如所现在就1个实例注册了进来，那么expectedNumberOfClientsSendingRenews=2
        this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfClientsSendingRenews
                * (60.0 / serverConfig.getExpectedClientRenewalIntervalSeconds())
                * serverConfig.getRenewalPercentThreshold());
    }


}
```